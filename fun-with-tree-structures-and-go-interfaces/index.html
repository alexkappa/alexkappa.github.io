<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v8.5.0 <https://hydejack.com/>
--><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>Fun with binary expression trees and Go | alex kalyvitis</title><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Fun with binary expression trees and Go" /><meta name="author" content="Alex Kalyvitis" /><meta property="og:locale" content="en" /><meta name="description" content="Recently, I found myself trying to implement a mechanism, able to evaluate expressions. Essentially what I needed was a binary expression tree. I used Go for this project, and quickly came to a delightful surprise that using Go’s extremely powerful interface mechanisms, it became extremely easy to implement and extend." /><meta property="og:description" content="Recently, I found myself trying to implement a mechanism, able to evaluate expressions. Essentially what I needed was a binary expression tree. I used Go for this project, and quickly came to a delightful surprise that using Go’s extremely powerful interface mechanisms, it became extremely easy to implement and extend." /><link rel="canonical" href="https://alexkappa.com/fun-with-tree-structures-and-go-interfaces/" /><meta property="og:url" content="https://alexkappa.com/fun-with-tree-structures-and-go-interfaces/" /><meta property="og:site_name" content="alex kalyvitis" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2014-04-16T00:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Fun with binary expression trees and Go" /><meta name="twitter:site" content="@alexkalyvitis" /><meta name="twitter:creator" content="@Alex Kalyvitis" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alex Kalyvitis"},"dateModified":"2014-04-16T00:00:00+00:00","datePublished":"2014-04-16T00:00:00+00:00","description":"Recently, I found myself trying to implement a mechanism, able to evaluate expressions. Essentially what I needed was a binary expression tree. I used Go for this project, and quickly came to a delightful surprise that using Go’s extremely powerful interface mechanisms, it became extremely easy to implement and extend.","headline":"Fun with binary expression trees and Go","mainEntityOfPage":{"@type":"WebPage","@id":"https://alexkappa.com/fun-with-tree-structures-and-go-interfaces/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://alexkappa.com/assets/icons/icon.png"},"name":"Alex Kalyvitis"},"url":"https://alexkappa.com/fun-with-tree-structures-and-go-interfaces/"}</script><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="alex kalyvitis"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="application-name" content="alex kalyvitis"><meta name="msapplication-config" content="/assets/ieconfig.xml"><meta name="theme-color" content="rgb(41,41,43)"><meta name="generator" content="Hydejack v8.5.0" /><link type="application/atom+xml" rel="alternate" href="https://alexkappa.com/feed.xml" title="alex kalyvitis" /><link rel="alternate" href="https://alexkappa.com/fun-with-tree-structures-and-go-interfaces/" hreflang="en"><link rel="shortcut icon" href="/assets/icons/favicon.ico"><link rel="apple-touch-icon" href="/assets/icons/icon.png"><link rel="manifest" href="/assets/manifest.json"><link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="dns-prefetch" href="/" id="_baseURL"><link rel="dns-prefetch" href="/assets/js/hydejack-legacy-8.5.0.js" id="_hrefJS"><link rel="dns-prefetch" href="/sw.js" id="_hrefSW"><link rel="dns-prefetch" href="/assets/bower_components/fontfaceobserver/fontfaceobserver.standalone.js" id="_hrefFFO"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.js" id="_hrefKatexJS"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.css" id="_hrefKatexCSS"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/contrib/copy-tex.min.js" id="_hrefKatexCopyJS"><link rel="dns-prefetch" href="/assets/bower_components/katex/dist/contrib/copy-tex.min.css" id="_hrefKatexCopyCSS"><link rel="dns-prefetch" href="/assets/img/swipe.svg" id="_hrefSwipeSVG"> <script> !function(e,t){"use strict";function n(e,t,n,r){e.addEventListener?e.addEventListener(t,n,r):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}e.loadJS=function(e,r){var o=t.createElement("script");o.src=e,r&&n(o,"load",r,{once:!0});var a=t.scripts[0];return a.parentNode.insertBefore(o,a),o},e._loaded=!1,e.loadJSDeferred=function(r,o){function a(){e._loaded=!0,o&&n(d,"load",o,{once:!0});var r=t.scripts[0];r.parentNode.insertBefore(d,r)}var d=t.createElement("script");return d.src=r,e._loaded?a():n(e,"load",a,{once:!0}),d},e.setRel=e.setRelStylesheet=function(e){function n(){this.rel="stylesheet"}var r=t.getElementById(e);r.addEventListener?r.addEventListener("load",n,{once:!0}):r.onload=n}}(window,document); !function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this); !function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this); !function(w, d) { w._noPushState = false; w._noDrawer = false; }(window, document); </script> <!--[if gt IE 8]><!----><link rel="stylesheet" href="/assets/css/hydejack-8.5.0.css"><link rel="stylesheet" href="/assets/icomoon/style.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata:500;700|Noto+Sans:300,300i,700,700i&display=swap"> <!--<![endif]--><body class="no-color-transition"><div id="_navbar" class="navbar fixed-top"><div class="content"><div class="nav-btn-bar"> <span class="sr-only">Jump to:</span> <a id="_menu" class="nav-btn no-hover fl" href="#_navigation"> <span class="sr-only">Navigation</span> <span class="icon-menu"></span> </a></div></div></div><hr class="sr-only" hidden /> <hy-push-state replace-ids="_main" link-selector="a[href]:not([href*='/assets/']):not(.external):not(.no-push-state)" duration="250" script-selector="script:not([type^='math/tex'])" prefetch ><main id="_main" class="content fade-in layout-post" role="main" data-color="rgb(217,218,220)" data-theme-color="rgb(41,41,43)" data-image="/assets/img/daniel-j-schwarz-XmC9mBSCPzM-unsplash.jpg" data-overlay ><article id="post-fun-with-tree-structures-and-go-interfaces" class="page post mb6" role="article"><header><h1 class="post-title"> Fun with binary expression trees and Go</h1><p class="post-date heading"> <time datetime="2014-04-16T00:00:00+00:00">16 Apr 2014</time> in <a href="/go/" class="flip-title">Go</a><div class="hr pb0"></div></header><p class="lead">Recently, I found myself trying to implement a mechanism, able to evaluate expressions. Essentially what I needed was a <a href="http://en.wikipedia.org/wiki/Binary_expression_tree">binary expression tree</a>. I used Go for this project, and quickly came to a delightful surprise that using Go’s extremely powerful interface mechanisms, it became extremely easy to implement and extend.<h2 id="before-we-dive-in">Before we dive in</h2><p>From Wikipedia:<blockquote><p>A binary expression tree is a specific application of a binary tree to evaluate certain expressions. Two common types of expressions that a binary expression tree can represent are algebraic and boolean. These trees can represent expressions that contain both unary and binary operators.</blockquote><blockquote><p>The leaves of a binary expression tree are operands, such as constants or variable names, and the other nodes contain operators.</blockquote><blockquote><p>These particular trees happen to be binary, because all of the operations are binary, and although this is the simplest case, it is possible for nodes to have more than two children. It is also possible for a node to have only one child, as is the case with the unary minus operator. An expression tree, T, can be evaluated by applying the operator at the root to the values obtained by recursively evaluating the left and right subtrees.</blockquote><p>So a binary expression tree<ul><li>can be algebraic (addition, multiplication, etc) or boolean (and, or, not).<li>has operands as leaves and operators as the other nodes.<li>node usually has two children, but it may have more (or one).</ul><h2 id="so-how-are-we-going-to-use-them">So how are we going to use them?</h2><p>Our need for binary expression trees arose by wanting to evaluate whether a set of url query parameters matches a particular pattern. So the pattern <code class="language-plaintext highlighter-rouge">date &gt;= 2014-01-01</code> should evaluate for <code class="language-plaintext highlighter-rouge">/path?date=2014-10-10</code> but should not evaluate for <code class="language-plaintext highlighter-rouge">/path?date=2013-12-12</code>. Alright that was too easy. How about combining conditions together with logical operators?<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(date &gt;= 2014-01-01) AND (lang == "EN")
</code></pre></div></div><p>And a little more complex expressions by combining logical operators: (date &gt;= 2014-01-01) AND ((lang == “EN”) OR NOT (foo = bar))<p>How do we go on from here? Well lets construct a boolean expression tree that represents this arbitrary handwritten expressions.<p><img src="/assets/img/content/fun-with-tree-structures-and-go-interfaces/binary_expression_tree_example-2.png" alt="alt" /><h2 id="okay-lets-code">Okay, lets code</h2><p>To get things started, it makes sense to see every node in the tree as an object, whose children are themselves objects. Starting from the top, the <code class="language-plaintext highlighter-rouge">AND</code> node could look like this:<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">And</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Left</span><span class="p">,</span> <span class="n">Right</span> <span class="k">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div><p>Now, although this looks simple enough, we haven’t yet addressed the trees functionality, which is why we need such a tree in the first place. Remeber we need to evaluate a set of query parameters against this tree and the response would be a simple true or false.<p>So lets add this to the topmost node we just created.<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="n">And</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">And</code> struct has a method called <code class="language-plaintext highlighter-rouge">Eval</code> which we can supply with parameters and it should tell us if the parameters match the conditions or not.<p>Now we need to write the implementation of the Eval method which should evaluate it’s children.<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="n">And</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">Left</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">.</span><span class="n">Right</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>Can you already see where I’m going with this? Struct <code class="language-plaintext highlighter-rouge">And</code> is a node in the tree, which has two children, themselves nodes in the tree. All of them have an <code class="language-plaintext highlighter-rouge">Eval</code> that take parameters as arguments and return a boolean.<p>If <code class="language-plaintext highlighter-rouge">And</code>, <code class="language-plaintext highlighter-rouge">Or</code>, <code class="language-plaintext highlighter-rouge">Not</code> and all the operators need to have an <code class="language-plaintext highlighter-rouge">Eval</code> function, we can group them by a common interface? Let’s call that interface <code class="language-plaintext highlighter-rouge">Node</code>.<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Node</span> <span class="k">interface</span><span class="p">{</span>
	<span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div></div><p>Let’s change the <code class="language-plaintext highlighter-rouge">And</code> struct to use Nodes as it’s children instead of arbitrary interfaces.<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">And</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Left</span><span class="p">,</span> <span class="n">Right</span> <span class="n">Node</span>
<span class="p">}</span>
</code></pre></div></div><p>Now the <code class="language-plaintext highlighter-rouge">Eval</code> method we defined on <code class="language-plaintext highlighter-rouge">And</code> is correct and would compile and run correctly. However our tree is incomplete as we haven’t defined <code class="language-plaintext highlighter-rouge">Or</code>, <code class="language-plaintext highlighter-rouge">Not</code> or any operators yet.<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Or</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Left</span><span class="p">,</span> <span class="n">Right</span> <span class="n">Node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">o</span> <span class="n">Or</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="n">Left</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">||</span> <span class="n">o</span><span class="o">.</span><span class="n">Right</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Not</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Elem</span> <span class="n">Node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">n</span> <span class="n">Not</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">n</span><span class="o">.</span><span class="n">Elem</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>With the above code we are able to construct and evaluate boolean expressions. To showcase an example, we’ll need a couple of helper structs, <code class="language-plaintext highlighter-rouge">True</code> and <code class="language-plaintext highlighter-rouge">False</code> which always evaluate to <code class="language-plaintext highlighter-rouge">true</code> and <code class="language-plaintext highlighter-rouge">false</code> respectively.<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">True</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">t</span> <span class="n">True</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">False</span> <span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">f</span> <span class="n">False</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>
</code></pre></div></div><p>Let’s try it out:<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t1</span> <span class="o">:=</span> <span class="n">And</span><span class="p">{</span><span class="n">True</span><span class="p">{},</span> <span class="n">True</span><span class="p">{}}</span>
<span class="n">t1</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="no">nil</span><span class="p">)</span> <span class="c">// returns true</span>

<span class="n">t2</span> <span class="o">:=</span> <span class="n">Or</span><span class="p">{</span><span class="n">False</span><span class="p">{},</span> <span class="n">True</span><span class="p">{}}</span>
<span class="n">t2</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="no">nil</span><span class="p">)</span> <span class="c">// returns true</span>
</code></pre></div></div><p>Next we can define algebraic expressions like <code class="language-plaintext highlighter-rouge">equals</code>, <code class="language-plaintext highlighter-rouge">greater than</code> and <code class="language-plaintext highlighter-rouge">less than</code>.<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Eq</span> <span class="k">struct</span><span class="p">{</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Value</span> <span class="kt">string</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">eq</span> <span class="n">Eq</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">val</span><span class="p">,</span> <span class="n">found</span> <span class="o">:=</span> <span class="n">p</span><span class="p">[</span><span class="n">eq</span><span class="o">.</span><span class="n">Key</span><span class="p">];</span> <span class="n">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">val</span> <span class="o">==</span> <span class="n">eq</span><span class="o">.</span><span class="n">Value</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Gt</span> <span class="k">struct</span><span class="p">{</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Value</span> <span class="kt">string</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">gt</span> <span class="n">Gt</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">val</span><span class="p">,</span> <span class="n">found</span> <span class="o">:=</span> <span class="n">p</span><span class="p">[</span><span class="n">gt</span><span class="o">.</span><span class="n">Key</span><span class="p">];</span> <span class="n">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">gt</span><span class="o">.</span><span class="n">Value</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Lt</span> <span class="k">struct</span><span class="p">{</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Value</span> <span class="kt">string</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">lt</span> <span class="n">Lt</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">val</span><span class="p">,</span> <span class="n">found</span> <span class="o">:=</span> <span class="n">p</span><span class="p">[</span><span class="n">lt</span><span class="o">.</span><span class="n">Key</span><span class="p">];</span> <span class="n">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">lt</span><span class="o">.</span><span class="n">Value</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>
</code></pre></div></div><p>Now lets construct the tree we drew out initially using the structures we created, and evaluate some parameters against it.<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tree</span> <span class="o">:=</span> <span class="n">And</span><span class="p">{</span>
	<span class="n">Eq</span><span class="p">{</span><span class="s">"date"</span><span class="p">,</span><span class="s">"2014-01-01"</span><span class="p">},</span>
	<span class="n">Or</span><span class="p">{</span>
		<span class="n">Eq</span><span class="p">{</span><span class="s">"lang"</span><span class="p">,</span><span class="s">"EN"</span><span class="p">},</span>
		<span class="n">Not</span><span class="p">{</span><span class="n">Eq</span><span class="p">{</span><span class="s">"foo"</span><span class="p">,</span><span class="s">"bar"</span><span class="p">}},</span>
	<span class="p">},</span>
<span class="p">}</span>

<span class="n">p</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
	<span class="s">"date"</span><span class="o">:</span> <span class="s">"2014-01-01"</span><span class="p">,</span>
	<span class="s">"lang"</span><span class="o">:</span> <span class="s">"EN"</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">tree</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c">// evaluates to true</span>
</code></pre></div></div><p>I’ve published the examples on <a href="http://github.com/alexkappa/tree">GitHub</a>, so feel free to fork the repo and adapt it to your needs.<h2 id="final-thoughts">Final thoughts</h2><p>Go’s interfaces made tree nodes easliy interchangeable and extremely easy to construct. Additionally, tree nodes can be added without any additions to the package. If you need to create your own operators (for example <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">before</code>, <code class="language-plaintext highlighter-rouge">after</code>) all you have to do is define an <code class="language-plaintext highlighter-rouge">Eval</code> method for it and it implicitly becomes a <code class="language-plaintext highlighter-rouge">Node</code>.<p>I’ve tried to keep the examples easy to follow, so I haven’t talked at all about operator values and type casting. For example you might want to implement a <code class="language-plaintext highlighter-rouge">before</code> or <code class="language-plaintext highlighter-rouge">after</code> operator that acts on dates, or a <code class="language-plaintext highlighter-rouge">contains</code> operator that acts on strings. The implementation of an operator is completely up to you, so if you need to type cast, or parse a date you are free to do so. A quick example:<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Before</span> <span class="k">struct</span><span class="p">{</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Value</span> <span class="kt">string</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">b</span> <span class="n">Before</span><span class="p">)</span> <span class="n">Eval</span><span class="p">(</span><span class="n">p</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">val</span><span class="p">,</span> <span class="n">found</span> <span class="o">:=</span> <span class="n">p</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">Key</span><span class="p">];</span> <span class="n">found</span> <span class="p">{</span>
		<span class="n">ta</span><span class="p">,</span> <span class="n">ea</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"2006-01-02"</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
		<span class="n">tb</span><span class="p">,</span> <span class="n">eb</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Parse</span><span class="p">(</span><span class="s">"2006-01-02"</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ea</span> <span class="o">!=</span> <span class="no">nil</span> <span class="o">||</span> <span class="n">eb</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">false</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ta</span><span class="o">.</span><span class="n">Before</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

</code></pre></div></div><p>Another thing I didn’t mention is that parameters in my use case came from the requests URL query parameters, meaning their type is <a href="http://golang.org/pkg/net/url/#Values"><code class="language-plaintext highlighter-rouge">url.Values</code></a>. <code class="language-plaintext highlighter-rouge">url.Values</code> is a map itself with additional getter and setter methods. So I adapted the <code class="language-plaintext highlighter-rouge">Node</code> interface’s arguments from <code class="language-plaintext highlighter-rouge">map[string]string</code> to <code class="language-plaintext highlighter-rouge">Parameters</code>. And <code class="language-plaintext highlighter-rouge">Parameters</code> is an interface defined like so:<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Parameters</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Get</span><span class="p">(</span><span class="n">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div><p>So instead of transforming a requests query parameters into a <code class="language-plaintext highlighter-rouge">map</code> before evaluating, I can simply pass a <code class="language-plaintext highlighter-rouge">url.Values</code> to <code class="language-plaintext highlighter-rouge">Eval</code> instead.<p><strong>Update</strong>: The source code is available on <a href="https://github.com/alexkappa/go-exp">GitHub</a> although it’s fairly modified and the API is changed quite heavily.<p>Thanks for reading!</article><hr class="dingbat related" /><aside class="about related mt4 mb4" role="complementary"><div class="author mt4"> <hy-img src="/assets/img/me.jpg" class="avatar" alt="Alex Kalyvitis" srcset="/assets/img/me.jpg 1x,/assets/img/me.jpg 2x" root-margin="512px" > <noscript><img data-ignore src="/assets/img/me.jpg" class="avatar" alt="Alex Kalyvitis" srcset="/assets/img/me.jpg 1x,/assets/img/me.jpg 2x" /></noscript> <span class="loading" slot="loading" hidden> <span class="icon-cog"></span> </span> </hy-img><h2 class="page-title hr"> About</h2><p>Software Engineer. Leader. Made in 🇨🇾. Fine-tuned in 🇳🇱.<div class="sidebar-social"> <span class="sr-only">Social:</span><ul><li> <a href="https://github.com/alexkappa" title="GitHub" class="no-mark-external"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a><li> <a href="https://www.linkedin.com/in/alex-kalyvitis" title="LinkedIn" class="no-mark-external"> <span class="icon-linkedin2"></span> <span class="sr-only">LinkedIn</span> </a><li> <a href="https://medium.com/@alexkappa" title="Medium" class="no-mark-external"> <span class="icon-medium"></span> <span class="sr-only">Medium</span> </a></ul></div></div></aside><aside class="related mb4" role="complementary"><h2 class="hr">Related Posts</h2><ul class="related-posts"><li> <a href="/json-polymorphism-in-go/" class="h4 flip-title"><span>JSON polymorphism in Go</span></a> <time class="heading faded fine" datetime="2020-03-15T00:00:00+00:00">15 Mar 2020</time><li> <a href="/go-trie/" class="h4 flip-title"><span>Trie</span></a> <time class="heading faded fine" datetime="2015-01-03T00:00:00+00:00">03 Jan 2015</time><li> <a href="/testing-in-go/" class="h4 flip-title"><span>Testing in Go</span></a> <time class="heading faded fine" datetime="2014-10-31T00:00:00+00:00">31 Oct 2014</time></ul></aside><footer role="contentinfo"><hr/><p><small class="copyright">© 2020 Alex Kalyvitis. All rights reserved. <br /> Cover photo by <a href="https://unsplash.com/@danieljschwarz">Daniel J. Schwarz</a> on <a href="https://unsplash.com/">Unsplash</a> </small><p><small>Powered by <a class="external" href="https://hydejack.com/">Hydejack</a> v<span id="_version">8.5.0</span></small><hr class="sr-only"/></footer></main><hy-drawer class="" align="left" threshold="10" touch-events prevent-default ><header id="_sidebar" class="sidebar" role="banner"><div class="sidebar-bg sidebar-overlay" style="background-color:rgb(41,41,43);background-image:url(/assets/img/daniel-j-schwarz-XmC9mBSCPzM-unsplash.jpg)"></div><div class="sidebar-sticky"><div class="sidebar-about"> <a class="no-hover" href="/" tabindex="-1"> <img src="/assets/icons/icon.png" class="avatar" alt="alex kalyvitis" data-ignore /> </a><h2 class="h1"><a href="/">alex kalyvitis</a></h2><p class=""> Director of Software Engineering at Blueground</div><nav class="sidebar-nav heading" role="navigation"> <span class="sr-only">Navigation:</span><ul><li> <a id="_navigation" href="/" class="sidebar-nav-item active" > Home </a><li> <a href="/about/" class="sidebar-nav-item" > About </a></ul></nav><div class="sidebar-social"> <span class="sr-only">Social:</span><ul><li> <a href="https://twitter.com/<username>" title="Twitter" class="no-mark-external"> <span class="icon-twitter"></span> <span class="sr-only">Twitter</span> </a><li> <a href="https://github.com/<username>" title="GitHub" class="no-mark-external"> <span class="icon-github"></span> <span class="sr-only">GitHub</span> </a></ul></div></div></header></hy-drawer><hr class="sr-only" hidden /> </hy-push-state> <!--[if gt IE 10]><!----> <script type="module">window.__ESM__=!0; import '/assets/js/hydejack-8.5.0.js';</script> <script nomodule>if (!window.__ESM__) loadJSDeferred(document.getElementById('_hrefJS').href);</script> <script>!function(w, d) { w.ga=w.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; /**/ ga('create', 'UA-15737971-1', 'auto'); /**/ var pushStateEl = d.getElementsByTagName('hy-push-state')[0]; var timeoutId; pushStateEl.addEventListener('hy-push-state-load', function() { w.clearTimeout(timeoutId); timeoutId = w.setTimeout(function() { ga('set', 'page', w.location.pathname); ga('send', 'pageview'); }, 500); }); d.addEventListener('hy--cookies-ok', function () { w.ga(function(tracker) { w.ga("set", "anonymizeIp", undefined); localStorage && localStorage.setItem("ga--client-id", tracker.get("clientId")); }); }); w.loadJSDeferred('https://www.google-analytics.com/analytics.js'); }(window, document);</script> <!--<![endif]--> <script> let textBox = document.querySelector(".sidebar-about > h2 > a"); let textBoxText = textBox.innerHTML; let altText = [textBoxText, "alexkappa"]; let altTextIndex = 0; let interval = 2000; let intervalId = window.setInterval(changeText, interval); window.setTimeout(() => { window.clearInterval(intervalId); }, (2 * interval) + 10); function fadeOut() { textBox.style.opacity = 0; } function fadeIn() { textBox.style.opacity = 1; } function changeInnerHtml() { altTextIndex = ++altTextIndex % altText.length; textBox.innerHTML = altText[altTextIndex]; } function changeText() { fadeOut(); window.setTimeout(() => { changeInnerHtml(); fadeIn(); }, 500); } </script><h2 class="sr-only" hidden>Templates (for web app):</h2><template id="_animation-template" hidden><div class="animation-main fixed-top"><div class="content"><div class="page"></div></div></div></template> <template id="_loading-template" hidden><div class="loading nav-btn fr"> <span class="sr-only">Loading…</span> <span class="icon-cog"></span></div></template> <template id="_error-template" hidden><div class="page"><h1 class="page-title">Error</h1><p class="lead"> Sorry, an error occurred while loading <a class="this-link" href=""></a>.</div></template> <template id="_forward-template" hidden> <button id="_forward" class="forward nav-btn no-hover fl"> <span class="sr-only">Forward</span> <span class="icon-arrow-right2"></span> </button> </template> <template id="_back-template" hidden> <button id="_back" class="back nav-btn no-hover fl"> <span class="sr-only">Back</span> <span class="icon-arrow-left2"></span> </button> </template> <template id="_permalink-template" hidden> <a href="#" class="permalink"> <span class="sr-only">Permalink</span> <span class="icon-link"></span> </a> </template></html>
